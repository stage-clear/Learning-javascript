# JavaScript関数型プログラミング 複雑性を抑える発想と実践法を学ぶ

[著者のGitHubリポジトリ](https://github.com/luijar/functional-programming-js)

## 目次
### 第１章 関数型で思考する
- 関数型プログラミングを学ぶと役に立つのか？<br>
- 関数型プログラミングとは何か？
  - 関数型プログラミングは宣言型である
  - 純粋関数と副作用問題
  - 参照透過性と代替性
  - データの不変性を維持
- 関数型プログラミングの利点
  - タスクをシンプルな関数に分解する
  - 円滑なチェーンを使ってデータ処理
  - 非同期アプリケーションの複雑性に対処する
- まとめ
### 第２章　関数型言語としてのJavaScript
- なぜJavaScriptなのか
- 関数型プログラミングvs. オブジェクト指向プログラミング
  - JavaScriptオブジェクトの状態管理
  - オブジェクトを値として扱う
  - 可動部分をディープフリーズ（再帰的にフリーズ）
  - レンズを使ってオブジェクトグラフを操作
- 関数
  - 第一級オブジェクトとしての関数
  - 高階関数
  - 関数呼び出しの方法
  - 関数メソッド
- クロージャとスコープ
  - グローバルスコープの問題
  - JavaScriptの関数スコープ
  - 疑似的なブロックスコープ
  - クロージャの実践的な利用方法
- まとめ
## 第３章　データ構造の数を減らし、操作の数を増やす
- アプリケーションの制御フローを理解する
- メソッドチェーン
- 関数チェーン
  - ラムダ式を理解する
  - データを _.map を使って交換する
  - _.reduce を使って結果を集める
  - _.filter を使って不要な要素を除去する
- コードを把握する
  - 宣言型および遅延関数チェーン
  - SQLライクなデータ: 関数としてのデータ
- 再帰的に考えることを学ぶ
  - 再帰とは何か
  - 再帰的に考えるということ
  - 再帰的に定義されるデータ構造
- まとめ
## 第４章　モジュール化によるコードの再利用
- メソッドチェーンと関数パイプライン
  - メソッドをまとめてチェーンにする
  - 関数をパイプライン状に配置する
- 互換性のある関数のための要件
  - 型互換の関数
  - 関数とアリティ: タプルの場合
- カリー化された関数評価
  - 関数ファクトリをエミュレートする
  - 再利用可能な関数テンプレートを実装する
- 部分適用とパラメータ束縛
  - コア言語を拡張する
  - 遅延関数に束縛する
- 関数パイプラインを合成する
  - HTMLウィジェットの合成を理解する
  - 関数合成: 記述を評価から分離する
  - 関数ライブラリによる合成
  - 純粋なコードと不純なコードを取り扱う
  - ポイントフリープログラミングの紹介
- 関数コンビネータを使ってフロー制御を管理する
  - identity（Iコンビネータ）
  - tap（Kコンビネータ）
  - alternation(ORコンビネータ)
  - sequence（Sコンビネータ）
  - fork（joinコンビネータ）
- まとめ
## 第５章 複雑性を抑えるデザインパターン
- 命令型エラー処理の欠点
  - try-catchによるエラー処理
  - 関数型プログラムで例外を投げない理由
  - nullチェックの問題
- より優れたソリューション: ファンクター
  - 安全ではない値のラッピング
  - ファンクターの詳細
- モナドを使った関数型エラー処理
  - モナド: 制御フローからデータフローへ
  - MaybeモナドとEitherモナドによるエラー処理
  - IOモナドを使用して外部リソースとやり取りする
- モナドチェーンと合成
- まとめ
## 第６章　関数型コードのテスト
- ユニットテストへの関数型プログラミングの影響
- 命令型プログラムのテストにおける課題
  - 単純なタスクを特定して分解することの困難さ
  - 共有リソースへの依存は不一致な結果をもたらす
  - あらかじめ定義された実行の順序
- 関数型コードをテストする
  - 関数をブラックボックスとして扱う
  - 制御フローではなくビジネスロジックに注目する
  - モナドの分離を用いて純粋なコードを不純なコードから分離する
  - 外部依存性をモックする
- プロパティベースのテストを利用して使用を把握する
- コードカバレッジにより有効性を測定する
  - 関数型コードのテストに関する有効性を測定する
  - 関数型コードの複雑度を測定する
- まとめ
## 第７章 関数型コードの最適化
- 関数実行の中身を調べる
  - カリー化と関数コンテキストスタック
  - 再帰コードの問題点
- 遅延評価を使用して実行を遅らせる
  - alternation関数コンビネータ（OR）により不要な計算を避ける
  - ショートカットフュージョンを利用する
- "必要に応じて呼び出す"戦略を実現する
  - メモ化を理解する
  - 計算が集中する関数をメモ化する
  - カリー化とメモ化を利用する
  - メモ化を最大限に利用するために分解を行う
  - メモ化を再帰呼び出しに適用する
- 再帰と末尾呼び出し最適化（TCO）
  - 非末尾呼び出しを末尾呼び出しに変換する
- まとめ
## 非同期イベント/データのための関数型手法
- 非同期コードの課題
  - 関数間の時間的な依存関係
  - コールバックピラミッドに陥る
  - 継続渡しスタイルを使う
- Promiseによる第一級非同期処理
  - thenメソッドチェーン
  - 同期処理と非同期処理の合成
- 遅延データ生成
  - ジェネレータと再帰
  - イテレータプロトコル
- RxJSによる関数型プログラミングとリアクティブプログラミング
  - オブザーバブルなシークエンスとしてのデータ
  - 関数型プログラミングとリアクティブプログラミング
  - RxJSとPromise
- まとめ
## 付録A 本書で使用したJavaScriptライブラリ
- A.1 関数型JavaScriptライブラリ
- A.2 本書で使用したその他のライブラリ
##　牽引
